# Структуры данных
- Массив 
    - (+) обращение к элементу за константное время
- List(ы) --- LinkedList
    - быстрое добавление и удаление элементов
- Stack / Queue
- Trees
    - бинарное дерево поиска
    - B+ дерево - любая реляционная база данных
- Dictionary linear probing

===

# Решить несколько задач
СКолько элементраных операций - будет в кр

int n = 4; // 1 - присваивание

for(int i=0; i < n; i++) {  // 2 + 3n
    if(i%2 == 0) {          // 1 + 1 n раз
        console.log(i);     // 1 n/2 раз
    }
}

ответ = 25

---

int[] array = new int[4]; // 1 (присваивание) + 1 выделение
int n = 4; // 1 - присваивание

for(int i=n; i > 0; i--) {  // 1 + 2n
    if(i%2 == 0) {          // 2n
        array[i] = i^2;     // n/2 * 3
    }
}

ответ = 2+1+1+2n+2n+3/2n = 31

---

ДЗ
2*n^4, 5log(n!*n), log(n^2 + n), n^(2n), (2n)!, 2^n, n^(log(n!)), nlog(n^10 + n), n!, 10n + 2018
разложить по возрастанию скорость асимптотического роста

Формула Стирлинга:

n! = Sqrt(2 Pi n) * (n/e)^n

Разницы нету для основания логарифма
log(n^n) > log(n!)



====

1. гибридная сортировка

Проверка: ксли размерность массива меньше чем Х то сортировать вставками
минимальная размерность 100.000 элементов
числа от 0 до миллиарда
QuickSort

должно быть <200

2. Параллельная сортировка

| name | age | salary |
| ---- | --- | ------ |
| alex | 27  | 5      |
| max  | 30  | 6      |
| john | 42  | 7      |
| Jane | 35  | 8      |
| bob  | 25  | 9      |

Нужно сделать синхронно за бонусы

| name | age | salary |
| ---- | --- | ------ |
| alex | 27  | 5      |
| max  | 30  | 6      |
| john | 42  | 7      |
| Jane | 35  | 8      |
| bob  | 25  | 9      |

# 4 lab

Эйлеров цикл|BFS
1 динамически достраивать граф (если есть список ребер 1 3 без 5 то добавить вершину 1 4 
Если инцидентности, то ребро 5 9 на месте должно появиться число )
2 Добавить/удалить ребро/вершину

Эйлеров цикл(по каждому ребру 1 раз):
Вводим граф Он рисует граф на листике, дорисовывает ребро и портит
Вывести, есть эйлеров цикл или нет, если есть вывести этот эйлеров цикл Использовать: односвязный граф
Проверка: на четность/нечетность всех вершин
Забиваем граф во время компиляции добавляет вершины(вершина вершина вес) и должно снова запустить для нового графа

BFS
1 Ввод графа, результатом работы алгоритма должно вывести какой компоненте связности принадлежит эта вершина
Далее он добавляет ребро и должно вывести тоже самое + то ребро компонента связности
Потом он еще ребро и снова показывает компоненты связности

2 Проверка на двудольность графа Если граф двудольный, то надо вывести по долям, кто какой доле принадлежит